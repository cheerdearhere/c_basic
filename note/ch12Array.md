# I. 배열 시작
## A. 사전적 정의
- 형식이 같은 자료 여러개를 모아 한 덩어리로 관리하는 문법
## B. 변수와 비교하기
- 변수
	- 메모리를 사용하는 문법
	- 자료형의 크기 내에 데이터 하나를 보관
	- 변수의 이름은 식별자
- 배열
	- 역시 메모리를 사용
	- 배열의 길이 * 자료의 크기 메모리 사용
	- 배열 자체의 이름도 있지만 배열을 구성하는 요소에도 인덱스를 붙여 식별
	- 배열의 이름은 식별자이자 주소(불변 = 상수)
```c
//선언
int data; // 변수 
int nList[4]; // 배열
//정의(초기화)
int data = 10; // 변수 
int nList[4] = { 0 }; // 배열
//식별
printf("%d\n",data);
printf("%d\n",nList[0]);
```

## C. 인덱스
- 여러 요소를 식별하기위해 인덱스(index)를 사용
- 0부터 시작(zero-based index)
- 배열의 이름은 0번 요소의 메모리 주소에 대한 식별자이며 상수(l-value 아님)
	- 0번 요소가 기준이됨. 0을 기준으로 떨어진 칸 수를 센다고 생각하면 됨
## D. 크기
- char[8] short[4] int[2]

![배열 크기](/img/array_memory.png)
- 인덱스 0만 식별. 그 이후 요소는 인덱스로 식별 
- char[]은 문자열 

|H|e|l|l|o|\n|
|---|

# II. 배열 사용하기
- []: 배열 연산자
## A. 초기화
- 선언과 정의 분리
```c
	int aList[5] = { 0 };
	aList[0] = 10;
	aList[1] = 20;
	aList[2] = 30;
	aList[3] = 40;
	aList[4] = 50;//배열명[인덱스] > l-value

//	aList = {10,20,30,40,50}; //l-value 아님
// 배열 이름은 식별자이자 주소이므로 직접 변경 불가
```
- 선언할때 배열의 크기를 지정하지 않고 인덱스 값을 직접 입력하는 경우
```c
	int bList[] = { 10,20,30,40,50 };
```
## B. 사용하기
- 여러 데이터를 갖는 배열은 각 요소를 직접 사용하기보다 반복문을 통해 사용하는 경우가 많음
- 반복문 내부에서 인덱스로 접근하다보니 횟수마다 인덱스 번호가 변경되야하는 만큼 while문보다 for문이 주로 사용됨
```c
for(int i = 0; i < 5; i++)
	printf("%d\t",aList[i]);
putchar('\n');
```
## C. 문자의 배열. 문자열
- 문자열은 char[]
- 문자열 상수란 쓰기가 허용되지 않는 이름이 없는 char[]
- 문자열의 끝은 반드시 \0(null/string zero)
- 문자열 상수는 보통 포인터를 사용해 관리
	- &로 zero index에 접근 > char*(character pointer)로 각 요소에 접근

## D. 실습예제
```dockerfile
문제: for문을 사용해 int[5] 배열에 저장된 값 중 가장 큰 값을 찾아 출력하는 프로그램을 작성
그후 가장 작은 값을 찾아 출력, int[0]에 최소값이 저장되도록함. 배열 요소의 값이 사라지지 않도록 교환
제한사항
	int nMax 사용
출력예시
	50 40 10 50 20
	MAX: 50
	MIN: 10
	10 40 50 50 20
```
[실습 예제](../c_basic/ch12Array/array_01Question.c)
# III. 정렬하기
- 버블 정렬: 최소값 구하기 반복
```dockerfile
문제: for문을 사용해 int[5] 배열에 저장된 값들을 오름 차순으로 정렬하는 프로그램
제한사항
	버블정렬 알고리즘 사용
출력 예시
	 50 40 10 50 20
	 정렬
	 10 20 40 50 50
	 3 5 1 4 2 
	 정렬
	 1 2 3 4 5
```
[실습 예제](../c_basic/ch12Array/array_02Question.c)

- selection sort(선택정렬): 값을 즉시 변경하는 버블정렬과 달리 최소값을 지닌 인덱스를 기억한뒤 외부 반복때 변경
```dockerfile
 for문을 사용해 int[5] 배열에 저장된 값들을 오름차순으로 정렬하는 프로그램
	선택정렬 알고리즘 사용
출력 예시
	 3 5 1 4 2 
	 정렬
	 1 2 3 4 5
```
[실습 예제](../c_basic/ch12Array/array_03Question.c)
- quick sort(퀵 정렬): 바이너리트리방식
```dockerfile
 for문을 사용해 int[5] 배열에 저장된 값들을 오름차순으로 정렬하는 프로그램
	퀵정렬 알고리즘 사용
출력 예시
	 3 5 1 4 2 
	 정렬
	 1 2 3 4 5
```
[실습 예제](../c_basic/ch12Array/array_04Question.c)

# IV. 다차원 배열
 - 배열 요소가 배열인 배열
	- 2차원 구조일 경우: [행][열] 
		- 정말 가끔
	- 3차원 구조일 경우: [면][행][열]
		- 거의 사용 x. 개념만
```c
int doubleD[1][2];
int thiedD[1][2][3];
```
- 중첩 반복문으로 내부에 데이터 사용
```c
int tArr[3][4] = {0}; //이렇게하면 모두 0으로 초기화
int innerNum = 0;
for (int i = 0; i < 3; i++) {
	for (int j = 0; j < 4; j++) {
		tArr[i][j] = ++innerNum;
	}
}

for (int i = 0; i < 3; i++) {
	for (int j = 0; j < 4; j++) {
		printf("%d\t", tArr[i][j]);
	}
	putchar('\n');
}
```
## A. 다차원 배열 실습
```c
 아래 배열 요소의 행, 열 총합을 다음과 같이 출력하는 프로그램 작성
제시된 배열
	int aList[3][4] = {
		{10,20,30},
		{40,50,60}
	};
출력 예시
	10	20	30	60
	40	50	60	150
	50	70	90	210
```
[실습 예제](../c_basic/ch12Array/array_05Question.c)
```c
for문을 사용해 int[5][5] 배열에 다음과 같이 저장하는 프로그램
예시
1	2	3	4	5
6	7	8	9	10
11	12	13	14	15
16	17	18	19	20	
21	22	23	24	25
```
[실습 예제](../c_basic/ch12Array/array_06Question.c)
- 머리가 정리되고 나서 코딩을 해라
	- 우선 논리 정리를 하고 그 결과를 코드로 옮기는 것
		- 잘 그리고 잘 적어서 정리한 다음
		- 코드로 결과를 보여라
```c
for문을 사용해 int[5][5] 배열에 다음과 같이 저장하는 프로그램
교차해서 증감
예시
1	2	3	4	5
10	9	8	7	6
11	12	13	14	15
20	19	18	17	16
21	22	23	24	25
```	
[실습 예제](../c_basic/ch12Array/array_07Question.c)
```c
for문을 사용해 int[5][5] 배열에 다음과 같이 저장하는 프로그램(달팽이 배열
예시
	1	2	3	4	5	
	16	17	18	19	6
	15	24	25	20	7
	14	23	22	21	8
	13	12	11	10	9
팁
	- 순차적으로 증가하는 칸으로 나눠서 보기
	- 가운데 값을 기준으로 변경되는 규칙 찾기
```
[실습 예제](../c_basic/ch12Array/array_08Question.c)

# V. 고급 기법 Lookup 배열
- 데이터를 검색 혹은 참조하기위해 사용
- 보통 기준에따라 인덱스 값을 계산하고 식별한 요소를 활용하는 구조
- 배열의 한 요소가 처리할 하나의 경우로 활용
- 실무에서 매우 잘쓰이므로 봐두면 도움됨
## A. 사용예시
- 제어문이나 다른 것 없이 데이터만 입력받으면 바로 처리가능 
```c
double aRate[10] = {
	0.0, 0.1, 0.25, // 1~3세
	0.5, 0.5,		// 4~5세
	0.6, 0.65,		// 6~7세
	0.8, 0.82, 0.97	// 8~9세
};
int nAge = 0, nFee = 1000;
printf("요금표\n");
for (int i = 1; i <= 10; ++i) {
	printf(
		"%d세 요금 : \t%d원\n",
		i,
		(int)(nFee * aRate[i - 1]) 
	);
}
```
- 단점: 사용자 입력에서 제한하지 않으면 그외의 값을 처리할 수 없다.
	- 경계를 확인하는 것은 기본 중 기본
	- 사용자 입력을 제한하고 검열하는 것은 당연
	- 성능을 올리는 가장 좋은 방법 
	- 함수 포인터를 lookup배열화 시키면 편리
	- 연산만으로 분기를 처리할 수 있다

[배열 전체 코드](../c_basic/ch12Array)